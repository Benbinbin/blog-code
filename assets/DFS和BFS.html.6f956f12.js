import{r as n,o as l,c as s,a,w as e,F as u,b as o}from"./app.93fa4a4f.js";const c={},t=a("h1",{id:"dfs和bfs",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#dfs和bfs","aria-hidden":"true"},"#"),o(" DFS和BFS")],-1),p=a("p",null,"搜索树和图有两种基本策略：",-1),i=a("ul",null,[a("li",null,"深度优先搜索 DFS，Deep First Search"),a("li",null,"广度优先搜索 BFS，Breath First Search")],-1),r=a("h2",{id:"深度优先搜索",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#深度优先搜索","aria-hidden":"true"},"#"),o(" 深度优先搜索")],-1),d=a("p",null,[o("贯彻了「不撞南墙不回头」的原则，只要没有碰壁就决不选择其它的道路，坚持向当前道路的深处挖掘（一直走到尾），常用于暴力搜索所有状态。深度优先搜索的核心思想是试图"),a("strong",null,"穷举"),o("所有的完整路径，以找到可行的路径。")],-1),k=a("p",null,"穷举法基本过程：",-1),b=a("ul",null,[a("li",null,"从入口位置为起点往前走"),a("li",null,"在前进的过程中可能遇到分支，只能选择其中的一条，然后继续前进（往后可能会不止一次遇到分支，每遇到一个新的分支，需要做一次选择）"),a("li",null,"选择的这条分支未必是一条通路，如果走到最后发现此路不通，那么你就要退回到离你最近的那个分叉路口"),a("li",null,"然后尝试看其它的分支能不能走通"),a("li",null,"如果当前的岔路口分叉出去的所有道路都走不通，那么就需要退回到当前岔路口的上一个岔路口，进一步去寻找新的路径"),a("li",null,"不断依次探寻分支，「最坏」的情况是穷举完所有分支，尝试到最后一种情况找到通路")],-1),m=a("p",null,[o("通过"),a("strong",null,"栈结构"),o("和"),a("strong",null,"递归"),o("编码实现深度优先搜索 DFS，因为在尝试分支岔路口时，会不断重复前进、后退的操作，其实和栈结构的入栈、出栈过程类似（后进先出），而二叉树的遍历一般使用递归来实现。")],-1),g=a("p",null,[a("img",{src:"/blog-code/assets/20200909120029738_22468.0e372481.png",alt:"DFS"})],-1),f=a("p",null,"把迷宫中的每一个坐标看做是栈里的一个元素，用栈来模拟这个过程（依次从上到下尝试分支）：",-1),h=a("ol",null,[a("li",null,[o("从 "),a("code",null,"A"),o(" 出发（"),a("code",null,"A"),o("入栈），经过了"),a("code",null,"B"),o("（"),a("code",null,"B"),o("入栈），接下来面临 "),a("code",null,"C"),o("、"),a("code",null,"D"),o("、"),a("code",null,"E"),o("三条路。这里按照从上到下的顺序来走（你也可以选择其它顺序），先走"),a("code",null,"C"),o("（"),a("code",null,"C"),o("入栈）。")]),a("li",null,[o("发现 "),a("code",null,"C"),o("是死胡同，后退到最近的岔路口 "),a("code",null,"B"),o("（"),a("code",null,"C"),o("出栈），尝试往"),a("code",null,"D"),o("方向走（"),a("code",null,"D"),o("入栈）。")]),a("li",null,[o("发现"),a("code",null,"D"),o(" 是死胡同，，后退到最近的岔路口 "),a("code",null,"B"),o("（"),a("code",null,"D"),o("出栈），尝试往"),a("code",null,"E"),o("方向走（"),a("code",null,"E"),o("入栈）。")]),a("li",null,[a("code",null,"E"),o(" 是一个岔路口，眼前有两个选择："),a("code",null,"F"),o(" 和 "),a("code",null,"G"),o("。按照从上到下的顺序来走，先走"),a("code",null,"F"),o("（"),a("code",null,"F"),o("入栈）。")]),a("li",null,[o("发现"),a("code",null,"F"),o(" 是死胡同，后退到最近的岔路口 "),a("code",null,"E"),o("（"),a("code",null,"F"),o("出栈），尝试往"),a("code",null,"G"),o("方向走（"),a("code",null,"G"),o("入栈）。")]),a("li",null,[a("code",null,"G"),o(" 是一个岔路口，眼前有两个选择："),a("code",null,"H"),o(" 和 "),a("code",null,"I"),o("。按照从上到下的顺序来走，先走"),a("code",null,"H"),o("（"),a("code",null,"H"),o("入栈）。")]),a("li",null,[o("发现 "),a("code",null,"H"),o(" 是死胡同，后退到最近的岔路口 "),a("code",null,"G"),o("（"),a("code",null,"H"),o("出栈），尝试往"),a("code",null,"I"),o("方向走（"),a("code",null,"I"),o("入栈）。")]),a("li",null,[a("code",null,"I"),o(" 就是出口，成功走出迷宫。")])],-1),F=a("p",null,[o("最后栈里保留的元素依次是"),a("code",null,"A"),o("、"),a("code",null,"B"),o("、"),a("code",null,"E"),o("、"),a("code",null,"G"),o("、"),a("code",null,"I"),o("，因此 "),a("code",null,"A"),o("->"),a("code",null,"B"),o("->"),a("code",null,"E"),o("->"),a("code",null,"G"),o("->"),a("code",null,"I"),o(" 就是走出迷宫的路径。")],-1),E=o("实际上使用"),B=o("先序遍历"),D=o("二叉树的所有结点就是 DFS 深度优先搜索思想的一种实现，可以说深度优先搜索过程就类似于树的先序遍历，是树的先序遍历的推广："),S=a("ul",null,[a("li",null,"从根结点出发，输出当前的结点内容，然后访问左侧的子结点（递归调用函数）"),a("li",null,"如果左子树同样存在左侧子结点，就头也不回地继续访问下去"),a("li",null,"一直到左侧子结点为空时，才退回到距离最近的父结点，再尝试去访问父结点的右侧子结点（递归调用函数）")],-1),A=a("p",null,"在这个递归函数中，递归式用来先后遍历左子树、右子树（分别探索不同的道路），递归边界是在识别到结点为空时会直接返回（撞到了南墙）。",-1),q=a("div",{class:"language-javascript ext-js line-numbers-mode"},[a("pre",{class:"language-javascript"},[a("code",null,[a("span",{class:"token comment"},"// 先序遍历二叉树所有结点"),o("\n"),a("span",{class:"token comment"},"// 入参是树的根结点对象"),o("\n"),a("span",{class:"token keyword"},"function"),o(),a("span",{class:"token function"},"preorder"),a("span",{class:"token punctuation"},"("),a("span",{class:"token parameter"},"root"),a("span",{class:"token punctuation"},")"),o(),a("span",{class:"token punctuation"},"{"),o("\n    "),a("span",{class:"token comment"},"// 递归边界，root 为空"),o("\n    "),a("span",{class:"token keyword"},"if"),a("span",{class:"token punctuation"},"("),a("span",{class:"token operator"},"!"),o("root"),a("span",{class:"token punctuation"},")"),o(),a("span",{class:"token punctuation"},"{"),o("\n        "),a("span",{class:"token keyword"},"return"),o("\n    "),a("span",{class:"token punctuation"},"}"),o("\n\n    "),a("span",{class:"token comment"},"// 输出当前遍历的结点值"),o("\n    console"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"log"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},"'当前遍历的结点值是：'"),a("span",{class:"token punctuation"},","),o(" root"),a("span",{class:"token punctuation"},"."),o("val"),a("span",{class:"token punctuation"},")"),o("\n    "),a("span",{class:"token comment"},"// 递归遍历左子树"),o("\n    "),a("span",{class:"token function"},"preorder"),a("span",{class:"token punctuation"},"("),o("root"),a("span",{class:"token punctuation"},"."),o("left"),a("span",{class:"token punctuation"},")"),o("\n    "),a("span",{class:"token comment"},"// 递归遍历右子树"),o("\n    "),a("span",{class:"token function"},"preorder"),a("span",{class:"token punctuation"},"("),o("root"),a("span",{class:"token punctuation"},"."),o("right"),a("span",{class:"token punctuation"},")"),o("\n"),a("span",{class:"token punctuation"},"}"),o("\n")])]),a("div",{class:"line-numbers"},[a("span",{class:"line-number"},"1"),a("br"),a("span",{class:"line-number"},"2"),a("br"),a("span",{class:"line-number"},"3"),a("br"),a("span",{class:"line-number"},"4"),a("br"),a("span",{class:"line-number"},"5"),a("br"),a("span",{class:"line-number"},"6"),a("br"),a("span",{class:"line-number"},"7"),a("br"),a("span",{class:"line-number"},"8"),a("br"),a("span",{class:"line-number"},"9"),a("br"),a("span",{class:"line-number"},"10"),a("br"),a("span",{class:"line-number"},"11"),a("br"),a("span",{class:"line-number"},"12"),a("br"),a("span",{class:"line-number"},"13"),a("br"),a("span",{class:"line-number"},"14"),a("br"),a("span",{class:"line-number"},"15"),a("br")])],-1),w=a("p",null,[o("在递归函数的底层就是用"),a("strong",null,"栈结构"),o("来实现的，JS 会维护一个叫「函数调用栈」的东西，"),a("code",null,"preorder"),o(" 每调用一次自己，相关调用的上下文就会被 "),a("code",null,"push"),o(" 进函数调用栈中；待函数执行完毕后，对应的上下文又会从调用栈中被 "),a("code",null,"pop"),o(" 出来（函数被递归调用时，较深的调用层会先被计算返回，然后其上一层函数才可以继续执行，这和栈后进先出类似）。因此，即便二叉树的递归调用过程中，并没有出现栈这种数据结构，也依然改变不了递归的本质是栈的事实。")],-1),C=a("h2",{id:"广度优先搜索",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#广度优先搜索","aria-hidden":"true"},"#"),o(" 广度优先搜索")],-1),G=a("p",null,[o("广度优先搜索 BFS 关心的是"),a("strong",null,"眼下自己能够直接到达的所有坐标"),o("，其动作有点类似于「扫描」，经过一层层的结点扫描，找到可以通往下一层的入口，最后达到出口。")],-1),v=a("p",null,"BFS 的遍历规则基本过程：",-1),y=a("ul",null,[a("li",null,"站在入口处（第一层），「扫描」下一层可以直接能抵达的岔路口"),a("li",null,"依次访问这些通路，记下哪些通路可以再到达下一层，记下这些结点"),a("li",null,"依次访问这些结点，看这些结点中哪些可以访问下一层，再记下可行的结点"),a("li",null,"重复「扫描」"),a("li",null,"直到最后到达出口")],-1),I=a("p",null,"在分层遍历的过程中有两个规律：",-1),H=a("ul",null,[a("li",null,"每访问完毕一个坐标，这个坐标在后续的遍历中都不会再被用到了，也就是说它可以被丢弃掉。"),a("li",null,"站在某个确定坐标的位置上，我们所观察到的可直接抵达的坐标，是需要被记录下来的，因为后续的遍历还要用到它们。")],-1),j=a("p",null,[a("img",{src:"/blog-code/assets/20200909130314218_21860.cb8397cd.png",alt:"BFS"})],-1),x=a("p",null,[o("丢弃已访问的坐标、记录新观察到的坐标，这个顺序符合「先进先出」的原则，因此可以使用"),a("strong",null,"队列结构"),o("编码实现广度优先搜索 BFS。")],-1),_=a("p",null,[o("用一个队列 "),a("code",null,"queue"),o(" 模拟 BFS 过程：")],-1),J=a("ol",null,[a("li",null,[o("初始化先将入口 "),a("code",null,"A"),o(" 入队。")]),a("li",null,[o("访问入口 "),a("code",null,"A"),o(" 发现直接能抵达的坐标只有"),a("code",null,"B"),o("，访问完毕后将"),a("code",null,"A"),o("出队，将"),a("code",null,"B"),o("入队。")]),a("li",null,[o("访问 "),a("code",null,"B"),o(" 发现直接能抵达的坐标变成了 "),a("code",null,"C"),o("、"),a("code",null,"D"),o(" 和 "),a("code",null,"E"),o("，于是把这三个坐标记为下一层的访问对象，访问完毕后将"),a("code",null,"B"),o("出队，将下一层结点全部入队")]),a("li",null,[o("访问第三层，这里按照从上到下的顺序，先访问 "),a("code",null,"C"),o("（访问完毕后 "),a("code",null,"C"),o(" 出队）和 "),a("code",null,"D"),o("（访问完毕后 "),a("code",null,"D"),o(" 出队），然后访问 "),a("code",null,"E"),o("（访问完毕后 "),a("code",null,"E"),o(" 出队）。访问 "),a("code",null,"C"),o(" 处和 "),a("code",null,"D"),o(" 处都没有见到新的可以直接抵达的坐标，所以不做额外的动作。但是在 "),a("code",null,"E"),o(" 处我们见到了可以直接抵达的 "),a("code",null,"F"),o(" 和 "),a("code",null,"G"),o("，因此把 "),a("code",null,"F"),o(" 和 "),a("code",null,"G"),o(" 记为下一层（第四层）需要访问的对象，"),a("code",null,"F"),o("、"),a("code",null,"G"),o("依次入队（"),a("code",null,"queue"),o("里现在是 "),a("code",null,"F"),o("、"),a("code",null,"G"),o("）。")]),a("li",null,[o("访问第五层。第五层按照从上到下的顺序，先访问的是 "),a("code",null,"H"),o("（访问完毕后 "),a("code",null,"H"),o(" 出队），发现从 "),a("code",null,"H"),o(" 出发没有可以直接抵达的坐标，因此不作额外的操作。接着访问 "),a("code",null,"I"),o("（访问完毕后 "),a("code",null,"I"),o(" 出队），发现 "),a("code",null,"I"),o(" 就是出口，问题得解（此时 "),a("code",null,"queue"),o(" 队列已经被清空）。")])],-1),L=a("p",null,"💡 在这个过程里循环往复地依次访问队列里已经有的坐标，将其出队；记录从当前坐标出发可直接抵达的所有坐标，将其入队（先进先出）。",-1),R=o("实际上使用"),z=o("迭代遍历中的"),K=a("strong",null,"层次遍历",-1),M=o("二叉树的所有结点就是 BFS 广度优先搜索思想的一种实现，即按照从上到下的层次顺序，从左到右地遍历一个二叉树。"),N=a("p",null,[a("img",{src:"/blog-code/assets/20200909132439637_13022.85aab959.png",alt:"层次遍历（红色数字即为遍历的序号）"})],-1),O=a("div",{class:"language-javascript ext-js line-numbers-mode"},[a("pre",{class:"language-javascript"},[a("code",null,[a("span",{class:"token comment"},"// BFS 伪代码"),o("\n"),a("span",{class:"token keyword"},"function"),o(),a("span",{class:"token constant"},"BFS"),a("span",{class:"token punctuation"},"("),a("span",{class:"token parameter"},"root"),a("span",{class:"token punctuation"},")"),o(),a("span",{class:"token punctuation"},"{"),o("\n    "),a("span",{class:"token keyword"},"const"),o(" queue "),a("span",{class:"token operator"},"="),o(),a("span",{class:"token punctuation"},"["),a("span",{class:"token punctuation"},"]"),o(),a("span",{class:"token comment"},"// 初始化队列queue"),o("\n    "),a("span",{class:"token comment"},"// 根结点首先入队"),o("\n    queue"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"push"),a("span",{class:"token punctuation"},"("),o("root"),a("span",{class:"token punctuation"},")"),o("\n    "),a("span",{class:"token comment"},"// 队列不为空，说明没有遍历完全"),o("\n    "),a("span",{class:"token keyword"},"while"),a("span",{class:"token punctuation"},"("),o("queue"),a("span",{class:"token punctuation"},"."),o("length"),a("span",{class:"token punctuation"},")"),o(),a("span",{class:"token punctuation"},"{"),o("\n        "),a("span",{class:"token keyword"},"const"),o(" top "),a("span",{class:"token operator"},"="),o(" queue"),a("span",{class:"token punctuation"},"["),a("span",{class:"token number"},"0"),a("span",{class:"token punctuation"},"]"),o(),a("span",{class:"token comment"},"// 取出队头元素"),o("\n        "),a("span",{class:"token comment"},"// 访问 top"),o("\n        console"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"log"),a("span",{class:"token punctuation"},"("),o("top"),a("span",{class:"token punctuation"},"."),o("val"),a("span",{class:"token punctuation"},")"),o("\n        "),a("span",{class:"token comment"},"// 如果左子树存在，左子树入队"),o("\n        "),a("span",{class:"token keyword"},"if"),a("span",{class:"token punctuation"},"("),o("top"),a("span",{class:"token punctuation"},"."),o("left"),a("span",{class:"token punctuation"},")"),o(),a("span",{class:"token punctuation"},"{"),o("\n            queue"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"push"),a("span",{class:"token punctuation"},"("),o("top"),a("span",{class:"token punctuation"},"."),o("left"),a("span",{class:"token punctuation"},")"),o("\n        "),a("span",{class:"token punctuation"},"}"),o("\n        "),a("span",{class:"token comment"},"// 如果右子树存在，右子树入队"),o("\n        "),a("span",{class:"token keyword"},"if"),a("span",{class:"token punctuation"},"("),o("top"),a("span",{class:"token punctuation"},"."),o("right"),a("span",{class:"token punctuation"},")"),o(),a("span",{class:"token punctuation"},"{"),o("\n            queue"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"push"),a("span",{class:"token punctuation"},"("),o("top"),a("span",{class:"token punctuation"},"."),o("right"),a("span",{class:"token punctuation"},")"),o("\n        "),a("span",{class:"token punctuation"},"}"),o("\n        queue"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"shift"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),o(),a("span",{class:"token comment"},"// 访问完毕，队头元素出队"),o("\n        "),a("span",{class:"token comment"},"// 继续执行迭代，取出队列下一个队头元素"),o("\n    "),a("span",{class:"token punctuation"},"}"),o("\n"),a("span",{class:"token punctuation"},"}"),o("\n")])]),a("div",{class:"line-numbers"},[a("span",{class:"line-number"},"1"),a("br"),a("span",{class:"line-number"},"2"),a("br"),a("span",{class:"line-number"},"3"),a("br"),a("span",{class:"line-number"},"4"),a("br"),a("span",{class:"line-number"},"5"),a("br"),a("span",{class:"line-number"},"6"),a("br"),a("span",{class:"line-number"},"7"),a("br"),a("span",{class:"line-number"},"8"),a("br"),a("span",{class:"line-number"},"9"),a("br"),a("span",{class:"line-number"},"10"),a("br"),a("span",{class:"line-number"},"11"),a("br"),a("span",{class:"line-number"},"12"),a("br"),a("span",{class:"line-number"},"13"),a("br"),a("span",{class:"line-number"},"14"),a("br"),a("span",{class:"line-number"},"15"),a("br"),a("span",{class:"line-number"},"16"),a("br"),a("span",{class:"line-number"},"17"),a("br"),a("span",{class:"line-number"},"18"),a("br"),a("span",{class:"line-number"},"19"),a("br"),a("span",{class:"line-number"},"20"),a("br"),a("span",{class:"line-number"},"21"),a("br"),a("span",{class:"line-number"},"22"),a("br")])],-1);c.render=function(o,c){const P=n("RouterLink");return l(),s(u,null,[t,p,i,r,d,k,b,m,g,f,h,F,a("p",null,[E,a(P,{to:"/algorithm/Frontend/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.html#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"},{default:e((()=>[B])),_:1}),D]),S,A,q,w,C,G,v,y,I,H,j,x,_,J,L,a("p",null,[R,a(P,{to:"/algorithm/Frontend/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.html"},{default:e((()=>[z,K])),_:1}),M]),N,O],64)};export default c;
