import{r as n,o as s,c as a,a as p,w as t,F as e,d as o,b as c}from"./app.93fa4a4f.js";const l={},u=o('<h1 id="排序" tabindex="-1"><a class="header-anchor" href="#排序" aria-hidden="true">#</a> 排序</h1><p>JavaScript 原生提供了对数组元素排序的方法 <code>arr.sort()</code>，实现排序只需要数行代码即可实现</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>arr<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> a <span class="token operator">-</span> b\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>但以面试为导向来看，一般会考察主要是以下 5 种算法的详细细节和优化：</p><ul><li>基础排序算法： <ul><li>冒泡排序</li><li>插入排序</li><li>选择排序</li></ul></li><li>进阶排序算法 <ul><li>归并排序</li><li>快速排序</li></ul></li></ul><p>💡 排序算法的<strong>时间复杂度</strong>也是一个不能忽视的考点</p><p>💡 在未经特别声明的情况下，都默认以「从小到大排列」为有序标准。</p><h2 id="冒泡排序" tabindex="-1"><a class="header-anchor" href="#冒泡排序" aria-hidden="true">#</a> 冒泡排序</h2><p>j基本的冒泡排序的过程，就是<strong>每次从第一个元素开始，重复比较相邻的两个项</strong>，若第一项比第二项更大，则交换两者的位置；反之不动。<strong>每一轮操作，都会将这一轮中最大的元素放置到数组的末尾</strong>，仿佛气泡浮出水面一样，被「冒」到了数组顶部。这也是冒泡排序得名的原因。</p><p>假如数组的长度是 <code>n</code>，那么当我们重复完 <code>n</code> 轮的时候，整个数组就有序了。</p><p>⚠️ 因为每一次从头到尾的遍历都只能定位到一个元素的位置（第 <code>n</code> 轮可以将较大的第 <code>n</code> 个元素定位到倒数第 <code>n</code> 位上），因此<strong>元素有多少个，总的循环就要执行多少轮</strong>。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token doc-comment comment">/**\n * basic bubble sort\n */</span>\n<span class="token keyword">function</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 数组长度决定遍历次数</span>\n  <span class="token keyword">const</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n  <span class="token comment">// 外层循环控制遍历（从头到尾的比较+交换）次数</span>\n  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 内层循环用于指示每一轮遍历两两元素的比较都是从数组的首位到[尾部-1]</span>\n    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 若相邻元素前面的数比后面大则进行互换（使用数组解构形式赋值交换）</span>\n      <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> arr<span class="token punctuation">;</span>   <span class="token comment">// 最后返回排序好的数组</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>其实随着外层循环的进行，<strong>数组尾部的元素会渐渐变得有序</strong>，即走完第 <code>n</code> 轮循环的时候，数组的后 <code>n</code> 个元素就已经是有序的，对于已经有序的部分可以不再进行遍历比较操作，以降低时间复杂度。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">betterBubbleSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 对内层循环的范围作了限制，对于第 i 轮，两两元素的比较从数组的首位到[第 i-1 位]</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> arr\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>💡 针对「最好」的情况，即在第一次冒泡的时候数组就完全有序，我们如果对这种作出特殊的标记，可以避免不必要的遍历，从而针对特殊的情况大大降低时间复杂度，<strong>将最好情况下的时间复杂度定向优化为 <code>O(n)</code></strong>。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">betterBubbleSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n\n    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 加了一个标志位，用于记录是否一开始（虽然也需要进行一轮遍历才能判断）数组就完全有序</span>\n        <span class="token keyword">let</span> flag <span class="token operator">=</span> <span class="token boolean">false</span>\n        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span>\n                <span class="token comment">// 只要发生了一次交换，就修改标志位</span>\n                flag <span class="token operator">=</span> <span class="token boolean">true</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token comment">// 若一次交换也没发生，则说明数组有序，直接放过</span>\n        <span class="token keyword">if</span><span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> arr<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> arr\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>冒泡排序的时间复杂度分最好、最坏和平均来看：</p><ul><li><strong>最好时间复杂度</strong>：它对应的是数组本身有序这种情况，只需要作比较（n-1 次），而不需要做交换，时间复杂度为 <strong>O(n)</strong></li><li><strong>最坏时间复杂度</strong>： 它对应的是数组完全逆序这种情况，每一轮内层循环都要执行，重复的总次数是 n(n-1)/2 次，因此时间复杂度是 <strong>O(n<sup>2</sup>)</strong></li><li><strong>平均时间复杂度</strong>：涉及到一些概率论的知识，这里记住平均时间复杂度是 <strong>O(n<sup>2</sup>)</strong> 即可</li></ul><h2 id="选择排序" tabindex="-1"><a class="header-anchor" href="#选择排序" aria-hidden="true">#</a> 选择排序</h2><p>选择排序是找出最小值放在头部。每次都找出当前范围内的最小值（第一次循环遍历整个数组），把它放在当前范围的头部；然后<strong>缩小排序范围</strong>，继续重复以上操作，直至数组完全有序为止。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">selectSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 数组长度</span>\n  <span class="token keyword">const</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n  <span class="token comment">// 缓存当前区间最小值的索引</span>\n  <span class="token keyword">let</span> minIndex<span class="token punctuation">;</span>\n  <span class="token comment">// i 是当前排序区间的起点索引</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 初始化 minIndex</span>\n    minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>\n    <span class="token comment">// 从 i 开始遍历区间的元素</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 若当前元素比当前的最小值还小，就更新最小值的索引为 j</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">// （如果最小值的索引不是当前区间的头部）对调元素，将最小值置于当前区间的头部</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span>minIndex <span class="token operator">!==</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 解构形式对调数组元素</span>\n      <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> arr\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>选择排序的最好情况也好，最坏情况也罢，都是要走内层循环作比较的（两者之间的区别仅仅在于元素交换的次数不同），因此的时间复杂度都对应两层循环消耗的时间量级 <strong>O(n<sup>2</sup>)</strong>。</p><p>💡 选择排序将较小的元素排到区间的头部，然后每次缩小比较的区间；类似于冒泡排序（优化版）的步骤，只不过冒泡排序是将较大的元素排到区间的尾部。但是选择排序是在每一轮内循环结束后才进行依一次元素交换；但冒泡排序是频繁地进行两两元素交换的。</p><h2 id="插入排序" tabindex="-1"><a class="header-anchor" href="#插入排序" aria-hidden="true">#</a> 插入排序</h2><p>插入排序所有的操作都基于一个这样的前提，当前元素<strong>前面的序列是有序的</strong>。然后需要插入的当前元素<strong>从这个有序序列的后面往前去寻找</strong>，在有序序列里找到正确位置插入。</p><p>💡 由于前面序列是有序的（从小到大），当前元素从后往前寻找，只要比较得到有序序列其中一个元素比自己小（就可以保证有序序列前面的元素都比自己小，因此一般不需要遍历完整个有序序列），即可找到正确的插入位置。<strong>通过正确地定位当前元素在有序序列里的位置、不断扩大有序数组的范围，最终达到完全排序的目的</strong>。</p><p>排序过程演示：原始数组 <code>[5, 3, 2, 4, 1]</code></p><ol><li><p>首先，单个数字一定有序，因此数组首位的这个 <code>5</code> 可以看做是一个有序序列。</p></li><li><p>在这样的前提下， 可以选中第二个元素 <code>3</code> 作为当前元素，思考它和前面那个序列 <code>[5]</code> 之间的关系。很明显， <code>3</code> 比 <code>5</code> 小，注意这里按照插入排序的原则，<strong>靠前的较大数字要为靠后的较小数字腾出位置</strong></p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">[</span>暂时空出<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>\n当前元素 <span class="token number">3</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>再往前看，发现没有更小的元素可以作比较了。那么现在空出的这个位置就是当前元素 <code>3</code> 应该待的地方 <code>[3, 5, 2, 4, 1]</code>。以上就完成了一轮插入，有序数组 <code>[5]</code> 现在变成了有序数组 <code>[3, 5]</code></p></li><li><p>沿着这个思路，继续往下走，当前元素变成了 <code>2</code>。对比 <code>2</code> 和 <code>5</code> 的大小，发现 <code>2</code> 比 <code>5</code> 小。按照插入排序的原则，<code>5</code>要往后挪，给较小元素空出一个位置：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> 暂时空出<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>\n当前元素 <span class="token number">2</span>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>接着继续向前对比，遇到了 <code>3</code>。对比 <code>3</code> 和 <code>2</code> 的大小，发现 <code>3</code> 比 <code>2</code> 大。按照插入排序的原则，<code>3</code>要往后挪，给较小元素空出一个位置：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">[</span>暂时空出<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>\n当前元素 <span class="token number">2</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>此时 <code>2</code> 前面的有序序列已经被对比完毕了。把 <code>2</code> 放到最终空出来的那个属于它的空位里去 <code>[2, 3, 5, 4, 1]</code>。以上完成了第二轮插入，有序数组变成了 <code>[2, 3, 5]</code>。</p></li><li><p>继续往下走，当前元素是 <code>4</code>。仍然是从后往前，首先对比 <code>4</code> 和 <code>5</code> 的大小，发现 <code>4</code> 比 <code>5</code> 小，那么 <code>5</code> 就要为更小的元素空出一个位置：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> 暂时空出<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>\n当前元素 <span class="token number">4</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>向前对比，遇到了 <code>3</code>。因为 <code>4</code> 比 <code>3</code> 大，符合从小到大的排序原则；<strong>同时已知当前这个序列是有序的，<code>3</code> 前面的数字一定都比 <code>3</code> 小，再继续向前查找就没有意义了</strong>。因此当前空出的这个坑就是 <code>4</code> 应该待的地方 <code>[2, 3, 4, 5, 1]</code></p></li><li><p>以此类推，最后一个元素 <code>1</code> 会被插入到 <code>[2, 3, 4, 5]</code> 这个序列的头部去，最终数组得以完全排序 <code>[1, 2, 3, 4, 5]</code></p></li></ol><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 数组长度</span>\n  <span class="token keyword">const</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n  <span class="token comment">// 保存当前需要插入的元素</span>\n  <span class="token keyword">let</span> temp<span class="token punctuation">;</span>\n  <span class="token comment">// 遍历数组的元素</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// j 用于作为游标，寻找合适的插入索引位置，从当前元素开始（从后往前）</span>\n    <span class="token keyword">let</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>\n    temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token comment">// 将游标不断从后往前移动，判断前面的元素是否比当前元素大</span>\n    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 如果是，需要将 j 前面的一个元素后移一位（则将游标再往前移动），为 temp 让出位置</span>\n      arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n      j<span class="token operator">--</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 直到遇到比 temp 小的元素或者到了数组头部，插入 temp</span>\n    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> arr\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><ul><li><p><strong>最好时间复杂度</strong>：它对应的数组本身就有序这种情况。此时内层循环只走一次，整体复杂度取决于外层循环，时间复杂度就是一层循环对应的 <strong>O(n)</strong>。</p></li><li><p><strong>最坏时间复杂度</strong>：它对应的是数组完全逆序这种情况。此时内层循环每次都要移动有序序列里的所有元素，因此时间复杂度对应的就是两层循环的 <strong>O(n<sup>2</sup>)</strong>。</p></li><li><p><strong>平均时间复杂度</strong>：<strong>O(n<sup>2</sup>)</strong></p></li></ul><h2 id="归并排序" tabindex="-1"><a class="header-anchor" href="#归并排序" aria-hidden="true">#</a> 归并排序</h2><p>归并排序是对<strong>分治思想</strong>的典型应用，它按照分治思想的框架进行排序：</p><ul><li><strong>分解子问题</strong>：将需要被排序的数组从中间分割为两半，然后再将分割出来的每个子数组各分割为两半，重复以上操作，直到单个子数组只有一个元素为止。</li><li><strong>求解每个子问题</strong>：从粒度最小的子数组开始，两两合并、确保每次合并出来的数组都是有序的，即对每个子数组进行排）。</li><li><strong>合并子问题的解，得出大问题的解</strong>：当数组被合并至原有的规模时，就得到了一个完全排序的数组。</li></ul><p>排序过程演示：原始数组 <code>[8, 7, 6, 5, 4, 3, 2, 1]</code></p><ul><li>分解子问题 <ol><li>将数组整个对半分 <code>[8, 7, 6, 5,| 4, 3, 2, 1]</code></li><li>对分割出的左右两个子数组各自对半分 <code>[8, 7,| 6, 5,| 4, 3,| 2, 1]</code></li><li>对四个子数组再进行各自对半分割，使得每个子数组内都<strong>只有一个元素</strong> <code>[8,| 7,| 6,| 5,| 4,| 3,| 2,| 1]</code></li></ol></li><li>解决每个子问题 <ol><li>将规模为 1 的子数组两两合并为规模为 2 的子数组，合并时确保有序 <code>[7, 8,| 5, 6,| 3, 4,| 1, 2]</code></li><li>接着将规模为 2 的按照有序原则合并为规模为 4 的子数组 <code>[5, 6, 7, 8,| 1, 2, 3, 4]</code></li></ol></li><li>得出大问题的解 最后将规模为 4 的子数组合并为规模为 8 的数组，得到完整的有序的数组 <code>[1, 2, 3, 4, 5, 6, 7, 8]</code></li></ul><p>💡 归并排序的核心是先通过<strong>分割</strong>再通过<strong>合并</strong>来实现，依托的是递归思想。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 数组长度</span>\n  <span class="token keyword">const</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n  <span class="token comment">// 处理递归边界</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> arr\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">// 计算数组左右分割点</span>\n  <span class="token keyword">const</span> mid <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// 递归分割左子数组</span>\n  <span class="token keyword">const</span> leftArr <span class="token operator">=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// 递归分割右子数组</span>\n  <span class="token keyword">const</span> rightArr <span class="token operator">=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>mid<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// 递归返回后，依次递归合并左右两个有序数组（每次递归合并都是按从小到大的，因此得到的都是有序数组）</span>\n  arr <span class="token operator">=</span> <span class="token function">mergeArr</span><span class="token punctuation">(</span>leftArr<span class="token punctuation">,</span> rightArr<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> arr\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">mergeArr</span><span class="token punctuation">(</span><span class="token parameter">arr1<span class="token punctuation">,</span> arr2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 初始化两个指针</span>\n  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>\n    j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n  <span class="token comment">// 初始化结果数组</span>\n  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token comment">// 数组 arr1 长度</span>\n  <span class="token keyword">const</span> len1 <span class="token operator">=</span> arr1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n  <span class="token comment">// 数组 arr2 长度</span>\n  <span class="token keyword">const</span> len2 <span class="token operator">=</span> arr2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n  <span class="token comment">// 合并两个有序数组，从小到大排列</span>\n  <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>len2 <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;</span>len2<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span>arr1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      i<span class="token operator">++</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      j<span class="token operator">++</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">// 考虑到其中一个子数组首先被遍历完的情况</span>\n  <span class="token comment">// 需要将另一个子数组的剩余的有序元素直接拼接到结果数组中</span>\n  <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>len1<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>arr1<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>arr2<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// 返回从小到大排列的有序数组</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br></div></div>',37),r=c("💡 两个有序数组的合并使用了双指针法，可以参考 "),i=c("合并两个有序数组"),k=o('<p>我们把每一次<strong>切分+归并</strong>看做是一轮。对于规模为 n 的数组来说，需要切分 log(n) 次（实际是 log<sub>2</sub>n 次），因此就有 log(n) 轮。</p><p>每一轮中，切分动作都是小事情，只需要固定的几步：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code> <span class="token comment">// 计算分割点</span>\n<span class="token keyword">const</span> mid <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>\n<span class="token comment">// 递归分割左子数组，然后合并为有序数组</span>\n<span class="token keyword">const</span> leftArr <span class="token operator">=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token comment">// 递归分割右子数组，然后合并为有序数组</span>\n<span class="token keyword">const</span> rightArr <span class="token operator">=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>mid<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>因此单次切分对应的是常数级别的时间复杂度 O(1)；而单次合并的时间复杂度为 O(n)（其中 n 是指两个子数组的元素个数和），因此决定归并排序时间复杂度的操作就是<strong>合并操作</strong>。</p><p>log(n) 轮对应 log(n) 次合并操作，因此归并排序的时间复杂度是 <strong>O(nlog(n))</strong></p><h2 id="快速排序" tabindex="-1"><a class="header-anchor" href="#快速排序" aria-hidden="true">#</a> 快速排序</h2><p>快速排序也是基于分而治之的原则实现的，但与归并排序的区别在于，它是直接在原有的数组内部进行排序。快速排序会<strong>将原始的数组筛选成较小和较大的两个子数组，然后<em>递归</em>地排序两个子数组</strong>。</p><p>排序过程演示：原始数组 <code>[5, 1, 3, 6, 2, 0, 7]</code></p><ol><li>首先选取一个基准值（基准值的选择有多种方式，示例选取中间的值），并在左右两端分别设定指针。</li></ol><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>\n         基准\n                   ↑\n ↑\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol start="2"><li>先移动<strong>左指针</strong>，直到找到一个<strong>不小于基准值</strong>的值为止；然后再移动<strong>右指针</strong>，直到找到一个<strong>不大于基准值</strong>的值为止。两端的指针满足条件时，停止移动的状态如下</li></ol><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>\n         基准\n                ↑\n          ↑\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol start="3"><li>如果左右指针没有<strong>越界</strong>（即左指针在右指针的右侧）就停下了（意味着基准值左边存在较大元素或右边存在较小元素），则交换左右指针的值，可以在划分的同时就让两边的元素「相对（与基准值）有序」，同时两个指针共同向中间走一步</li></ol><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>\n             ↑ 基准\n             ↑\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>💡 可能存在交换的值就是基准值的情况，如示例，但不影响比较。</p><ol start="4"><li>此时 2 比 6 小，故右指针不动，左指针继续前进，此时右指针所指的值不大于 6，左指针所指的值不小于 6，故两个指针都不再移动，而且指针<strong>越界</strong>*了。</li></ol><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>\n               基准\n             ↑\n           right\n                ↑\n               left\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol start="5"><li>此时可以基于<strong>左指针</strong>来划分左右两个子数组，对于左指针所指的数字来说，它左边的所有数字都比它小，右边的所有数字都比它大（也可能存在相等的情况）。由此就能够<strong>以左指针为轴心，划分出一左一右、一小一大两个子数组</strong>。</li></ol><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>\n<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ol start="6"><li>针对两个子数组，重复执行以上操作，直到数组完全排序为止。</li></ol><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 快速排序</span>\n<span class="token keyword">function</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 定义递归边界，若数组只有一个元素，则没有排序必要</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// lineIdex 表示划分左右子数组的索引</span>\n    <span class="token keyword">const</span> lineIndex <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span>\n    <span class="token comment">// 如果左边子数组的长度不小于 1（如果子数组只有一个元素则 left = lineIndex-1），则递归快排该子数组</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> lineIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 左子数组以 lineIndex-1 为右边界</span>\n      <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> lineIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 如果右边子数组的长度不小于 1（如果子数组只有一个元素则 lineIndex = right），则递归快排该子数组</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>lineIndex <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 右子数组以 lineIndex 为左边界</span>\n      <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> lineIndex<span class="token punctuation">,</span> right<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> arr\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 以基准值划分左右子数组的过程</span>\n<span class="token keyword">function</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 默认取中间位置元素作为基准值</span>\n  <span class="token keyword">let</span> pivotValue <span class="token operator">=</span> arr<span class="token punctuation">[</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token comment">// 初始化左右指针</span>\n  <span class="token keyword">let</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span>\n  <span class="token keyword">let</span> j <span class="token operator">=</span> right<span class="token punctuation">;</span>\n  <span class="token comment">// 当左右指针不越界时，循环移动指针</span>\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 左指针所指元素若小于基准值，则一直右移左指针</span>\n    <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivotValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      i<span class="token operator">++</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 右指针所指元素若大于基准值，则一直左移右指针</span>\n    <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> pivotValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      j<span class="token operator">--</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 如果没有越界，但两指针已满足条件「停下」，意味着基准值左边存在较大元素或右边存在较小元素</span>\n    <span class="token comment">// 则直接对调指针所指元素，确保左右两侧的大小有序（相对于基准值），并分别往中间走一步，继续执行循环，直到越界</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      i<span class="token operator">++</span><span class="token punctuation">;</span>\n      j<span class="token operator">--</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// 指针越界后，返回左指针作为划分子数组的索引</span>\n  <span class="token keyword">return</span> i<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 快速排序过程中常常会在指针越界前交换左右指针的值，提取成一个独立的函数</span>\n<span class="token keyword">function</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br></div></div><p>快速排序的时间复杂度的好坏，是由基准值来决定的：</p><ul><li><strong>最好时间复杂度</strong>：每次选择基准值都刚好是当前子数组的中间数。这时可以确保每一次分割都能将数组分为两半，进而只需要递归 log(n) 次，和归并排序相似，最后结果也是 <strong>O(nlog(n))</strong></li><li><strong>最坏时间复杂度</strong>：每次划分取到的都是当前数组中的最大值/最小值，把这种情况代入快排的思路中，此时快排已经退化为了冒泡排序，对应的时间复杂度是 <strong>O(n<sup>2</sup>)</strong></li><li><strong>平均时间复杂度</strong>： <strong>O(nlog(n))</strong></li></ul>',23);l.render=function(o,c){const l=n("RouterLink");return s(),a(e,null,[u,p("p",null,[r,p(l,{to:"/algorithm/Frontend/%E6%95%B0%E7%BB%84%E5%BA%94%E7%94%A8.html#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"},{default:t((()=>[i])),_:1})]),k],64)};export default l;
