import{r as n,o as s,c as a,a as t,w as e,F as c,b as l}from"./app.93fa4a4f.js";const p={},o=t("h1",{id:"递归与回溯思想",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#递归与回溯思想","aria-hidden":"true"},"#"),l(" 递归与回溯思想")],-1),u=t("p",null,"回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，其核心思想是如果发现当前路径已不满足求解条件时，就「回溯」返回，尝试别的路径。",-1),r=t("p",null,"回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为「回溯点」。许多复杂的，规模较大的问题都可以使用回溯法，有「通用解题方法」的美称。",-1),i=t("p",null,[l("这里的「回溯」二字可以理解为是在 "),t("strong",null,"DFS 过程中「退一步重新选择」这个动作"),l("， DFS 算法其实就是回溯思想的体现。")],-1),k=t("p",null,"💡 回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。",-1),b=t("h2",{id:"全排列问题",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#全排列问题","aria-hidden":"true"},"#"),l(" 全排列问题")],-1),m=t("blockquote",null,[t("p",null,[l("题目描述：给定一个"),t("strong",null,"没有重复"),l("数字的序列，返回其所有可能的全排列。 💡 全排列是指：从 "),t("code",null,"n"),l(" 个不同元素中任取 "),t("code",null,"m"),l("（m≤n）个元素，按照一定的顺序排列起来，叫做从 "),t("code",null,"n"),l(" 个不同元素中取出 "),t("code",null,"m"),l(" 个元素的一个排列。当 "),t("code",null,"m=n"),l(" 时所有的排列情况叫全排列。即拿到一个 "),t("code",null,"n"),l(" 个元素的数组作为入参，穷举出这 "),t("code",null,"n"),l(" 个数的"),t("strong",null,"所有排列方式"),l("。")]),t("p",null,[l("示例：输入："),t("code",null,"[1,2,3]"),l(" 输出：")]),t("div",{class:"language-javascript ext-js line-numbers-mode"},[t("pre",{class:"language-javascript"},[t("code",null,[t("span",{class:"token punctuation"},"["),l("\n  "),t("span",{class:"token punctuation"},"["),t("span",{class:"token number"},"1"),t("span",{class:"token punctuation"},","),t("span",{class:"token number"},"2"),t("span",{class:"token punctuation"},","),t("span",{class:"token number"},"3"),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},","),l("\n  "),t("span",{class:"token punctuation"},"["),t("span",{class:"token number"},"1"),t("span",{class:"token punctuation"},","),t("span",{class:"token number"},"3"),t("span",{class:"token punctuation"},","),t("span",{class:"token number"},"2"),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},","),l("\n  "),t("span",{class:"token punctuation"},"["),t("span",{class:"token number"},"2"),t("span",{class:"token punctuation"},","),t("span",{class:"token number"},"1"),t("span",{class:"token punctuation"},","),t("span",{class:"token number"},"3"),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},","),l("\n  "),t("span",{class:"token punctuation"},"["),t("span",{class:"token number"},"2"),t("span",{class:"token punctuation"},","),t("span",{class:"token number"},"3"),t("span",{class:"token punctuation"},","),t("span",{class:"token number"},"1"),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},","),l("\n  "),t("span",{class:"token punctuation"},"["),t("span",{class:"token number"},"3"),t("span",{class:"token punctuation"},","),t("span",{class:"token number"},"1"),t("span",{class:"token punctuation"},","),t("span",{class:"token number"},"2"),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},","),l("\n  "),t("span",{class:"token punctuation"},"["),t("span",{class:"token number"},"3"),t("span",{class:"token punctuation"},","),t("span",{class:"token number"},"2"),t("span",{class:"token punctuation"},","),t("span",{class:"token number"},"1"),t("span",{class:"token punctuation"},"]"),l("\n"),t("span",{class:"token punctuation"},"]"),l("\n")])]),t("div",{class:"line-numbers"},[t("span",{class:"line-number"},"1"),t("br"),t("span",{class:"line-number"},"2"),t("br"),t("span",{class:"line-number"},"3"),t("br"),t("span",{class:"line-number"},"4"),t("br"),t("span",{class:"line-number"},"5"),t("br"),t("span",{class:"line-number"},"6"),t("br"),t("span",{class:"line-number"},"7"),t("br"),t("span",{class:"line-number"},"8"),t("br")])])],-1),d=t("p",null,"可以将问题转换为「填坑」情景。手里有 3 个数，要往这 3 个坑里填，有几种填法？",-1),f=t("ol",null,[t("li",null,[l("面对第一个坑，有 3 种选择：填 "),t("code",null,"1"),l("、填 "),t("code",null,"2"),l(" 或填 "),t("code",null,"3"),l("，随机选择其中一个填进去即可。")]),t("li",null,"面对第二个坑，由于第一步中已经分出去 1 个数字，现在只剩下 2 个选择。"),t("li",null,"面对第三个坑，由于前面已经消耗了 2 个数字，此时我们手里只剩下 1 个数字了。所以说第 3 个坑是毫无悬念的，它只有1种可能。")],-1),g=t("p",null,[t("img",{src:"/blog-code/assets/20200915092725474_29875.ae3eaa4c.png",alt:"全排列（图中以圆点为起点，以箭头为终点，起点和终点之间就是一个完整的排列）"})],-1),h=l("::: info 一个思维工具：只要分析出重复的逻辑（排除掉类似数组遍历这种简单粗暴的重复），需要把"),w=t("strong",null,"递归",-1),y=l("从你的大脑内存里调度出来，将其列为「可以一试」的解法之一，而只要想到递归，就应该立刻想到 "),v=t("strong",null,"DFS 思想",-1),x=l("。 :::"),j=t("p",null,[t("strong",null,"递归式"),l("：示例的「填坑」过程中重复地做了以下事情")],-1),F=t("ol",null,[t("li",null,"检查手里剩下的数字有哪些"),t("li",null,"选取其中一个填进当前的坑里")],-1),S=t("p",null,[t("strong",null,"递归边界"),l("：递归式的动作一直持续到了最后一个数字也被填进坑里为止，可以用数组中可选数字是否为空，或坑位是否已填满来判断是否达到递归边界。")],-1),D=t("div",{class:"language-javascript ext-js line-numbers-mode"},[t("pre",{class:"language-javascript"},[t("code",null,[t("span",{class:"token doc-comment comment"},[l("/**\n * "),t("span",{class:"token keyword"},"@param"),l(),t("span",{class:"token class-name"},[t("span",{class:"token punctuation"},"{"),l("number"),t("span",{class:"token punctuation"},"["),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},"}")]),l(),t("span",{class:"token parameter"},"nums"),l("\n * "),t("span",{class:"token keyword"},"@return"),l(),t("span",{class:"token class-name"},[t("span",{class:"token punctuation"},"{"),l("number"),t("span",{class:"token punctuation"},"["),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},"["),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},"}")]),l("\n */")]),l("\n\n"),t("span",{class:"token keyword"},"function"),l(),t("span",{class:"token function"},"permute"),t("span",{class:"token punctuation"},"("),t("span",{class:"token parameter"},"nums"),t("span",{class:"token punctuation"},")"),l(),t("span",{class:"token punctuation"},"{"),l("\n  "),t("span",{class:"token keyword"},"const"),l(" len "),t("span",{class:"token operator"},"="),l(" nums"),t("span",{class:"token punctuation"},"."),l("length"),t("span",{class:"token punctuation"},";"),l("\n  "),t("span",{class:"token comment"},"// 记录当前排列"),l("\n  "),t("span",{class:"token keyword"},"let"),l(" curr "),t("span",{class:"token operator"},"="),l(),t("span",{class:"token punctuation"},"["),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},";"),l("\n  "),t("span",{class:"token comment"},"// 记录所有排列"),l("\n  "),t("span",{class:"token keyword"},"let"),l(" res "),t("span",{class:"token operator"},"="),l(),t("span",{class:"token punctuation"},"["),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},";"),l("\n  "),t("span",{class:"token comment"},"// 使用对象模拟 Map 结构，记录以使用的数字，避免重复使用同一个数字"),l("\n  "),t("span",{class:"token keyword"},"let"),l(" visited "),t("span",{class:"token operator"},"="),l(),t("span",{class:"token punctuation"},"{"),t("span",{class:"token punctuation"},"}"),t("span",{class:"token punctuation"},";"),l("\n\n  "),t("span",{class:"token comment"},"// 核心函数，遍历数组，生成排列"),l("\n  "),t("span",{class:"token comment"},"// 入参是坑位的索引（从 0 开始计数）"),l("\n  "),t("span",{class:"token keyword"},"function"),l(),t("span",{class:"token function"},"dfs"),t("span",{class:"token punctuation"},"("),t("span",{class:"token parameter"},"nth"),t("span",{class:"token punctuation"},")"),l(),t("span",{class:"token punctuation"},"{"),l("\n    "),t("span",{class:"token comment"},"// 当遍历到了不存在的坑位（第 len+1 个），表示到达递归边界"),l("\n    "),t("span",{class:"token keyword"},"if"),t("span",{class:"token punctuation"},"("),l("nth "),t("span",{class:"token operator"},"==="),l(" len"),t("span",{class:"token punctuation"},")"),l(),t("span",{class:"token punctuation"},"{"),l("\n      "),t("span",{class:"token comment"},"// push 当前排列到 res 中，记录当前 len 个坑位已填满的排列"),l("\n      res"),t("span",{class:"token punctuation"},"."),t("span",{class:"token function"},"push"),t("span",{class:"token punctuation"},"("),l("curr"),t("span",{class:"token punctuation"},"."),t("span",{class:"token function"},"slice"),t("span",{class:"token punctuation"},"("),t("span",{class:"token punctuation"},")"),t("span",{class:"token punctuation"},")"),t("span",{class:"token punctuation"},";"),l("   "),t("span",{class:"token comment"},"// 使用 slice 创造数组副本，而不是引用"),l("\n      "),t("span",{class:"token keyword"},"return"),l("   "),t("span",{class:"token comment"},"// 返回上一层递归"),l("\n    "),t("span",{class:"token punctuation"},"}"),l("\n    "),t("span",{class:"token comment"},"// 遍历数组元素，依次以元素作为首个元素生成排列"),l("\n    "),t("span",{class:"token keyword"},"for"),t("span",{class:"token punctuation"},"("),t("span",{class:"token keyword"},"let"),l(" i"),t("span",{class:"token operator"},"="),t("span",{class:"token number"},"0"),t("span",{class:"token punctuation"},";"),l(" i"),t("span",{class:"token operator"},"<"),l("len"),t("span",{class:"token punctuation"},";"),l(" i"),t("span",{class:"token operator"},"++"),t("span",{class:"token punctuation"},")"),l(),t("span",{class:"token punctuation"},"{"),l("\n      "),t("span",{class:"token comment"},"// 若 visited 该元素并没有标记，对应值为 0，表示该元素可以使用填入当前坑位"),l("\n      "),t("span",{class:"token keyword"},"if"),t("span",{class:"token punctuation"},"("),t("span",{class:"token operator"},"!"),l("visited"),t("span",{class:"token punctuation"},"["),l("nums"),t("span",{class:"token punctuation"},"["),l("i"),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},")"),l(),t("span",{class:"token punctuation"},"{"),l("\n        "),t("span",{class:"token comment"},"// 将元素 push 到当前排列中"),l("\n        curr"),t("span",{class:"token punctuation"},"."),t("span",{class:"token function"},"push"),t("span",{class:"token punctuation"},"("),l("nums"),t("span",{class:"token punctuation"},"["),l("i"),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},")"),t("span",{class:"token punctuation"},";"),l("\n        "),t("span",{class:"token comment"},"// 为当前使用过的元素打上「已用过」的标，即添加到 visited 中并设置值为 1"),l("\n        visited"),t("span",{class:"token punctuation"},"["),l("nums"),t("span",{class:"token punctuation"},"["),l("i"),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},"]"),l(),t("span",{class:"token operator"},"="),l(),t("span",{class:"token number"},"1"),t("span",{class:"token punctuation"},";"),l("\n        "),t("span",{class:"token comment"},"// 递归调用，基于当前排列继续往下一个坑位走去"),l("\n        "),t("span",{class:"token function"},"dfs"),t("span",{class:"token punctuation"},"("),l("nth"),t("span",{class:"token operator"},"+"),t("span",{class:"token number"},"1"),t("span",{class:"token punctuation"},")"),t("span",{class:"token punctuation"},";"),l("\n        "),t("span",{class:"token comment"},"// 递归返回后（当前的排列完成，由于递归是栈结构层层嵌套，因此只有最深递归结束才依次层层返回）"),l("\n        "),t("span",{class:"token comment"},"// 依次清空各层递归中添加到 visited 中的元素 和 元素的「已用过」标记，以便下一个循环使用"),l("\n        "),t("span",{class:"token comment"},"// nums[i] 让出当前坑位"),l("\n        curr"),t("span",{class:"token punctuation"},"."),t("span",{class:"token function"},"pop"),t("span",{class:"token punctuation"},"("),t("span",{class:"token punctuation"},")"),t("span",{class:"token punctuation"},";"),l("\n        "),t("span",{class:"token comment"},"// 去掉「已用过」标记"),l("\n        visited"),t("span",{class:"token punctuation"},"["),l("nums"),t("span",{class:"token punctuation"},"["),l("i"),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},"]"),l(),t("span",{class:"token operator"},"="),l(),t("span",{class:"token number"},"0"),t("span",{class:"token punctuation"},";"),l("\n      "),t("span",{class:"token punctuation"},"}"),l("\n    "),t("span",{class:"token punctuation"},"}"),l("\n  "),t("span",{class:"token punctuation"},"}"),l("\n  "),t("span",{class:"token comment"},"// 从 0 坑位开始调用核心函数 dfs"),l("\n  "),t("span",{class:"token function"},"dfs"),t("span",{class:"token punctuation"},"("),t("span",{class:"token number"},"0"),t("span",{class:"token punctuation"},")"),t("span",{class:"token punctuation"},";"),l("\n  "),t("span",{class:"token keyword"},"return"),l(" res"),t("span",{class:"token punctuation"},";"),l("\n"),t("span",{class:"token punctuation"},"}"),l("\n")])]),t("div",{class:"line-numbers"},[t("span",{class:"line-number"},"1"),t("br"),t("span",{class:"line-number"},"2"),t("br"),t("span",{class:"line-number"},"3"),t("br"),t("span",{class:"line-number"},"4"),t("br"),t("span",{class:"line-number"},"5"),t("br"),t("span",{class:"line-number"},"6"),t("br"),t("span",{class:"line-number"},"7"),t("br"),t("span",{class:"line-number"},"8"),t("br"),t("span",{class:"line-number"},"9"),t("br"),t("span",{class:"line-number"},"10"),t("br"),t("span",{class:"line-number"},"11"),t("br"),t("span",{class:"line-number"},"12"),t("br"),t("span",{class:"line-number"},"13"),t("br"),t("span",{class:"line-number"},"14"),t("br"),t("span",{class:"line-number"},"15"),t("br"),t("span",{class:"line-number"},"16"),t("br"),t("span",{class:"line-number"},"17"),t("br"),t("span",{class:"line-number"},"18"),t("br"),t("span",{class:"line-number"},"19"),t("br"),t("span",{class:"line-number"},"20"),t("br"),t("span",{class:"line-number"},"21"),t("br"),t("span",{class:"line-number"},"22"),t("br"),t("span",{class:"line-number"},"23"),t("br"),t("span",{class:"line-number"},"24"),t("br"),t("span",{class:"line-number"},"25"),t("br"),t("span",{class:"line-number"},"26"),t("br"),t("span",{class:"line-number"},"27"),t("br"),t("span",{class:"line-number"},"28"),t("br"),t("span",{class:"line-number"},"29"),t("br"),t("span",{class:"line-number"},"30"),t("br"),t("span",{class:"line-number"},"31"),t("br"),t("span",{class:"line-number"},"32"),t("br"),t("span",{class:"line-number"},"33"),t("br"),t("span",{class:"line-number"},"34"),t("br"),t("span",{class:"line-number"},"35"),t("br"),t("span",{class:"line-number"},"36"),t("br"),t("span",{class:"line-number"},"37"),t("br"),t("span",{class:"line-number"},"38"),t("br"),t("span",{class:"line-number"},"39"),t("br"),t("span",{class:"line-number"},"40"),t("br"),t("span",{class:"line-number"},"41"),t("br"),t("span",{class:"line-number"},"42"),t("br"),t("span",{class:"line-number"},"43"),t("br"),t("span",{class:"line-number"},"44"),t("br"),t("span",{class:"line-number"},"45"),t("br"),t("span",{class:"line-number"},"46"),t("br")])],-1),E=t("p",null,[l("⚠️ 模拟 Map 结构 "),t("code",null,"visited"),l(" 的使用：填坑时，每用到一个数字，我们都要给这个数字打上「已用过」的标记，避免它被使用第二次；数字让出坑位时，对应的排列和 "),t("code",null,"visited"),l(" 状态也需要被及时地更新掉。 ⚠️ 当走到递归边界时，一个完整的排列也到手了。将这个完整排列推入结果数组时，用了 "),t("code",null,"res.push(curr.slice())"),l(" 而不是简单的 "),t("code",null,"res.push(curr)"),l(" 因为全局只有一个唯一的 "),t("code",null,"curr"),l("，它的值会随着 "),t("code",null,"dfs"),l(" 的进行而不断被更新。 "),t("code",null,"slice"),l(" 方法的作用是帮助我们拷贝出一个不影响 "),t("code",null,"curr"),l(" 正本的副本，以防直接修改到 "),t("code",null,"curr"),l(" 的引用。")],-1),B=t("h2",{id:"组合问题",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#组合问题","aria-hidden":"true"},"#"),l(" 组合问题")],-1),_=t("blockquote",null,[t("p",null,[l("题目描述：给定一组不含重复元素的整数数组 "),t("code",null,"nums"),l("，返回该数组所有可能的子集（幂集）。 💡 解集不能包含重复的子集。")]),t("p",null,[l("示例: 输入: "),t("code",null,"nums = [1, 2, 3]"),l(" 输出")]),t("div",{class:"language-javascript ext-js line-numbers-mode"},[t("pre",{class:"language-javascript"},[t("code",null,[t("span",{class:"token punctuation"},"["),l("\n  "),t("span",{class:"token punctuation"},"["),t("span",{class:"token number"},"3"),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},","),l("\n  "),t("span",{class:"token punctuation"},"["),t("span",{class:"token number"},"1"),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},","),l("\n  "),t("span",{class:"token punctuation"},"["),t("span",{class:"token number"},"2"),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},","),l("\n  "),t("span",{class:"token punctuation"},"["),t("span",{class:"token number"},"1"),t("span",{class:"token punctuation"},","),l(),t("span",{class:"token number"},"2"),t("span",{class:"token punctuation"},","),l(),t("span",{class:"token number"},"3"),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},","),l("\n  "),t("span",{class:"token punctuation"},"["),t("span",{class:"token number"},"1"),t("span",{class:"token punctuation"},","),l(),t("span",{class:"token number"},"3"),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},","),l("\n  "),t("span",{class:"token punctuation"},"["),t("span",{class:"token number"},"2"),t("span",{class:"token punctuation"},","),l(),t("span",{class:"token number"},"3"),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},","),l("\n  "),t("span",{class:"token punctuation"},"["),t("span",{class:"token number"},"1"),t("span",{class:"token punctuation"},","),l(),t("span",{class:"token number"},"2"),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},","),l("\n  "),t("span",{class:"token punctuation"},"["),t("span",{class:"token punctuation"},"]"),l("\n"),t("span",{class:"token punctuation"},"]"),l("\n")])]),t("div",{class:"line-numbers"},[t("span",{class:"line-number"},"1"),t("br"),t("span",{class:"line-number"},"2"),t("br"),t("span",{class:"line-number"},"3"),t("br"),t("span",{class:"line-number"},"4"),t("br"),t("span",{class:"line-number"},"5"),t("br"),t("span",{class:"line-number"},"6"),t("br"),t("span",{class:"line-number"},"7"),t("br"),t("span",{class:"line-number"},"8"),t("br"),t("span",{class:"line-number"},"9"),t("br"),t("span",{class:"line-number"},"10"),t("br")])])],-1),q=t("p",null,[l("💡 组合问题返回该数组所有可能的子集，出现穷举大概率会用到 DFS，只要用到 DFS 就应该想到递归思维方式，其中核心是构建"),t("strong",null,"递归式"),l("和定义"),t("strong",null,"递归边界"),l("。")],-1),A=t("p",null,[l("在上一道题中，"),t("strong",null,"排列的顺序是变化的"),l("，而每个排列中数字的个数却是不变的，即「坑位」的个数是确定不变的，可以作为递归边界；在这道题中，每个组合中数字的个数是不确定的（即每个数字在组合中的存在性不确定），但不变的东西变成了"),t("strong",null,"可以参与组合的数字"),l("，因此我们的思路可以调整为，从每一个数字入手，讨论它出现或者不出现的情况。")],-1),C=t("p",null,[t("img",{src:"/blog-code/assets/20200915105746545_19324.7f6d3755.png",alt:"组合（对于数组的每个元素都有取或不取两种状态，对应于树结构的两个分叉）"})],-1),M=t("p",null,[t("strong",null,"递归式"),l("：检查手里剩下的数字有哪些（因为强调了数字不能重复使用），选取其中一个填进当前的坑里、或者干脆把这个坑空出来（这里就体现了存在性而非顺序）。")],-1),L=t("p",null,[t("strong",null,"递归边界"),l("：组合里数字个数的最大值，如示例只给了 3 个数，因此组合里数字最多也只有 3 个，超过 3 个则视为触碰递归边界，即直接以 for 语句遍历所有的数字作为递归边界，当数组的元素遍历完全时，也就意味着递归走到了尽。。")],-1),R=t("div",{class:"language-javascript ext-js line-numbers-mode"},[t("pre",{class:"language-javascript"},[t("code",null,[t("span",{class:"token doc-comment comment"},[l("/**\n * "),t("span",{class:"token keyword"},"@param"),l(),t("span",{class:"token class-name"},[t("span",{class:"token punctuation"},"{"),l("number"),t("span",{class:"token punctuation"},"["),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},"}")]),l(),t("span",{class:"token parameter"},"nums"),l("\n * "),t("span",{class:"token keyword"},"@return"),l(),t("span",{class:"token class-name"},[t("span",{class:"token punctuation"},"{"),l("number"),t("span",{class:"token punctuation"},"["),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},"["),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},"}")]),l("\n */")]),l("\n\n"),t("span",{class:"token keyword"},"function"),l(),t("span",{class:"token function"},"subsets"),t("span",{class:"token punctuation"},"("),t("span",{class:"token parameter"},"nums"),t("span",{class:"token punctuation"},")"),l(),t("span",{class:"token punctuation"},"{"),l("\n  "),t("span",{class:"token keyword"},"const"),l(" len "),t("span",{class:"token operator"},"="),l(" nums"),t("span",{class:"token punctuation"},"."),l("length"),t("span",{class:"token punctuation"},";"),l("\n  "),t("span",{class:"token comment"},"// 记录当前组合"),l("\n  "),t("span",{class:"token keyword"},"let"),l(" curr "),t("span",{class:"token operator"},"="),l(),t("span",{class:"token punctuation"},"["),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},";"),l("\n  "),t("span",{class:"token comment"},"// 记录所有组合"),l("\n  "),t("span",{class:"token keyword"},"let"),l(" res "),t("span",{class:"token operator"},"="),l(),t("span",{class:"token punctuation"},"["),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},";"),l("\n\n  "),t("span",{class:"token comment"},"// 核心函数，遍历数组，生成组合"),l("\n  "),t("span",{class:"token comment"},"// 入参是 nums 中的数字索引，一般取 index=0 从第一个元素开始遍历"),l("\n  "),t("span",{class:"token keyword"},"function"),l(),t("span",{class:"token function"},"dfs"),t("span",{class:"token punctuation"},"("),t("span",{class:"token parameter"},"index"),t("span",{class:"token punctuation"},")"),l(),t("span",{class:"token punctuation"},"{"),l("\n    "),t("span",{class:"token comment"},"// 每次（递归调用）进入函数都意味着当前组合内容更新一次，故直接推入结果数组中"),l("\n    res"),t("span",{class:"token punctuation"},"."),t("span",{class:"token function"},"push"),t("span",{class:"token punctuation"},"("),l("curr"),t("span",{class:"token punctuation"},"."),t("span",{class:"token function"},"slice"),t("span",{class:"token punctuation"},"("),t("span",{class:"token punctuation"},")"),t("span",{class:"token punctuation"},")"),t("span",{class:"token punctuation"},";"),l(),t("span",{class:"token comment"},"// 使用 slice 创造数组副本，而不是引用"),l("\n    "),t("span",{class:"token comment"},"// 从当前数字的索引开始，遍历 nums"),l("\n    "),t("span",{class:"token keyword"},"for"),l(),t("span",{class:"token punctuation"},"("),t("span",{class:"token keyword"},"let"),l(" i "),t("span",{class:"token operator"},"="),l(" index"),t("span",{class:"token punctuation"},";"),l(" i "),t("span",{class:"token operator"},"<"),l(" len"),t("span",{class:"token punctuation"},";"),l(" i"),t("span",{class:"token operator"},"++"),t("span",{class:"token punctuation"},")"),l(),t("span",{class:"token punctuation"},"{"),l("\n      "),t("span",{class:"token comment"},"// 这是当前数字存在于组合中的情况"),l("\n      curr"),t("span",{class:"token punctuation"},"."),t("span",{class:"token function"},"push"),t("span",{class:"token punctuation"},"("),l("nums"),t("span",{class:"token punctuation"},"["),l("i"),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},")"),t("span",{class:"token punctuation"},";"),l("\n      "),t("span",{class:"token comment"},"// 基于当前数字存在于组合中的情况，进一步 dfs（递归），遍历判断数组下一个元素的存在情况"),l("\n      "),t("span",{class:"token function"},"dfs"),t("span",{class:"token punctuation"},"("),l("i "),t("span",{class:"token operator"},"+"),l(),t("span",{class:"token number"},"1"),t("span",{class:"token punctuation"},")"),t("span",{class:"token punctuation"},";"),l("\n      "),t("span",{class:"token comment"},"// 底层递归结束后依次返回，pop 出当前递归层中添加的元素，并作为这是当前数字不存在与组合中的情况，再返回上一层时就可以添加到 res 中"),l("\n      curr"),t("span",{class:"token punctuation"},"."),t("span",{class:"token function"},"pop"),t("span",{class:"token punctuation"},"("),t("span",{class:"token punctuation"},")"),t("span",{class:"token punctuation"},";"),l("\n    "),t("span",{class:"token punctuation"},"}"),l("\n  "),t("span",{class:"token punctuation"},"}"),l("\n\n  "),t("span",{class:"token comment"},"// 从数组第一个元素进入 dfs"),l("\n  "),t("span",{class:"token function"},"dfs"),t("span",{class:"token punctuation"},"("),t("span",{class:"token number"},"0"),t("span",{class:"token punctuation"},")"),t("span",{class:"token punctuation"},";"),l("\n  "),t("span",{class:"token keyword"},"return"),l(" res"),t("span",{class:"token punctuation"},";"),l("\n"),t("span",{class:"token punctuation"},"}"),l("\n")])]),t("div",{class:"line-numbers"},[t("span",{class:"line-number"},"1"),t("br"),t("span",{class:"line-number"},"2"),t("br"),t("span",{class:"line-number"},"3"),t("br"),t("span",{class:"line-number"},"4"),t("br"),t("span",{class:"line-number"},"5"),t("br"),t("span",{class:"line-number"},"6"),t("br"),t("span",{class:"line-number"},"7"),t("br"),t("span",{class:"line-number"},"8"),t("br"),t("span",{class:"line-number"},"9"),t("br"),t("span",{class:"line-number"},"10"),t("br"),t("span",{class:"line-number"},"11"),t("br"),t("span",{class:"line-number"},"12"),t("br"),t("span",{class:"line-number"},"13"),t("br"),t("span",{class:"line-number"},"14"),t("br"),t("span",{class:"line-number"},"15"),t("br"),t("span",{class:"line-number"},"16"),t("br"),t("span",{class:"line-number"},"17"),t("br"),t("span",{class:"line-number"},"18"),t("br"),t("span",{class:"line-number"},"19"),t("br"),t("span",{class:"line-number"},"20"),t("br"),t("span",{class:"line-number"},"21"),t("br"),t("span",{class:"line-number"},"22"),t("br"),t("span",{class:"line-number"},"23"),t("br"),t("span",{class:"line-number"},"24"),t("br"),t("span",{class:"line-number"},"25"),t("br"),t("span",{class:"line-number"},"26"),t("br"),t("span",{class:"line-number"},"27"),t("br"),t("span",{class:"line-number"},"28"),t("br"),t("span",{class:"line-number"},"29"),t("br"),t("span",{class:"line-number"},"30"),t("br"),t("span",{class:"line-number"},"31"),t("br"),t("span",{class:"line-number"},"32"),t("br")])],-1),z=t("h2",{id:"限定组合问题",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#限定组合问题","aria-hidden":"true"},"#"),l(" 限定组合问题")],-1),G=t("blockquote",null,[t("p",null,[l("题目描述：给定两个整数 "),t("code",null,"n"),l(" 和 "),t("code",null,"k"),l("，返回 1~n 中所有可能的 k 个数的组合。 示例：输入："),t("code",null,"n = 4, k = 2"),l(" 输出：")]),t("div",{class:"language-javascript ext-js line-numbers-mode"},[t("pre",{class:"language-javascript"},[t("code",null,[t("span",{class:"token punctuation"},"["),l("\n  "),t("span",{class:"token punctuation"},"["),t("span",{class:"token number"},"2"),t("span",{class:"token punctuation"},","),l(),t("span",{class:"token number"},"4"),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},","),l("\n  "),t("span",{class:"token punctuation"},"["),t("span",{class:"token number"},"3"),t("span",{class:"token punctuation"},","),l(),t("span",{class:"token number"},"4"),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},","),l("\n  "),t("span",{class:"token punctuation"},"["),t("span",{class:"token number"},"2"),t("span",{class:"token punctuation"},","),l(),t("span",{class:"token number"},"3"),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},","),l("\n  "),t("span",{class:"token punctuation"},"["),t("span",{class:"token number"},"1"),t("span",{class:"token punctuation"},","),l(),t("span",{class:"token number"},"2"),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},","),l("\n  "),t("span",{class:"token punctuation"},"["),t("span",{class:"token number"},"1"),t("span",{class:"token punctuation"},","),l(),t("span",{class:"token number"},"3"),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},","),l("\n  "),t("span",{class:"token punctuation"},"["),t("span",{class:"token number"},"1"),t("span",{class:"token punctuation"},","),l(),t("span",{class:"token number"},"4"),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},","),l("\n"),t("span",{class:"token punctuation"},"]"),l("\n")])]),t("div",{class:"line-numbers"},[t("span",{class:"line-number"},"1"),t("br"),t("span",{class:"line-number"},"2"),t("br"),t("span",{class:"line-number"},"3"),t("br"),t("span",{class:"line-number"},"4"),t("br"),t("span",{class:"line-number"},"5"),t("br"),t("span",{class:"line-number"},"6"),t("br"),t("span",{class:"line-number"},"7"),t("br"),t("span",{class:"line-number"},"8"),t("br")])])],-1),H=t("p",null,"这是组合问题的一种变体，限制了组合中的元素个数，即在深度优先搜索中，要去掉一些不符合题目要求的、没有作用的分支，及时回溯（递归返回），这个过程形似剪掉树的枝叶，所以这一方法被称为「剪枝」。",-1),I=t("p",null,[l("假如 "),t("code",null,"n=3， k=2"),l("，那么需要输出的内容就如下图的红色箭头所示")],-1),J=t("p",null,[t("img",{src:"/blog-code/assets/20200916103833785_12896.11b776f8.png",alt:"限定组合（只有双向箭头所指的结点组合被认为是有效结果，其它结点都被丢弃）"})],-1),K=t("p",null,"需要基于组合问题对递归式和递归边界进行修改：",-1),N=t("p",null,[t("strong",null,"递归式"),l("：当且仅当组合内数字个数为 "),t("code",null,"k"),l(" 个时，才会对组合结果数组进行更新。 "),t("strong",null,"递归边界"),l("：相应地如果组合内数字个数达到了 "),t("code",null,"k"),l(" 个，就不再继续当前的路径往下遍历，而是直接返回。")],-1),O=t("div",{class:"language-javascript ext-js line-numbers-mode"},[t("pre",{class:"language-javascript"},[t("code",null,[t("span",{class:"token doc-comment comment"},[l("/**\n * "),t("span",{class:"token keyword"},"@param"),l(),t("span",{class:"token class-name"},[t("span",{class:"token punctuation"},"{"),l("number"),t("span",{class:"token punctuation"},"}")]),l(),t("span",{class:"token parameter"},"n"),l("\n * "),t("span",{class:"token keyword"},"@param"),l(),t("span",{class:"token class-name"},[t("span",{class:"token punctuation"},"{"),l("number"),t("span",{class:"token punctuation"},"}")]),l(),t("span",{class:"token parameter"},"k"),l("\n * "),t("span",{class:"token keyword"},"@return"),l(),t("span",{class:"token class-name"},[t("span",{class:"token punctuation"},"{"),l("number"),t("span",{class:"token punctuation"},"["),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},"["),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},"}")]),l("\n */")]),l("\n\n"),t("span",{class:"token keyword"},"function"),l(),t("span",{class:"token function"},"combine"),t("span",{class:"token punctuation"},"("),t("span",{class:"token parameter"},[l("n"),t("span",{class:"token punctuation"},","),l(" k")]),t("span",{class:"token punctuation"},")"),l(),t("span",{class:"token punctuation"},"{"),l("\n  "),t("span",{class:"token comment"},"// 记录当前组合"),l("\n  "),t("span",{class:"token keyword"},"let"),l(" curr "),t("span",{class:"token operator"},"="),l(),t("span",{class:"token punctuation"},"["),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},";"),l("\n  "),t("span",{class:"token comment"},"// 记录所有组合"),l("\n  "),t("span",{class:"token keyword"},"let"),l(" res "),t("span",{class:"token operator"},"="),l(),t("span",{class:"token punctuation"},"["),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},";"),l("\n\n  "),t("span",{class:"token comment"},"// 核心函数，遍历数组，生成组合"),l("\n  "),t("span",{class:"token comment"},"// 入参是索引，根据题目要求取 index=1， 遍历由正整数 1~n 组成的数组"),l("\n  "),t("span",{class:"token keyword"},"function"),l(),t("span",{class:"token function"},"dfs"),t("span",{class:"token punctuation"},"("),t("span",{class:"token parameter"},"index"),t("span",{class:"token punctuation"},")"),l(),t("span",{class:"token punctuation"},"{"),l("\n    "),t("span",{class:"token keyword"},"if"),t("span",{class:"token punctuation"},"("),l("curr"),t("span",{class:"token punctuation"},"."),l("length "),t("span",{class:"token operator"},"==="),l(" k"),t("span",{class:"token punctuation"},")"),l(),t("span",{class:"token punctuation"},"{"),l("\n      "),t("span",{class:"token comment"},"// 每次（递归调用）进入函数都判断当前组合中的元素个数"),l("\n      "),t("span",{class:"token comment"},"// 当数量为 k 个时，表示达到递归边界，就 push 到 res 中，并返回"),l("\n      res"),t("span",{class:"token punctuation"},"."),t("span",{class:"token function"},"push"),t("span",{class:"token punctuation"},"("),l("curr"),t("span",{class:"token punctuation"},"."),t("span",{class:"token function"},"slice"),t("span",{class:"token punctuation"},"("),t("span",{class:"token punctuation"},")"),t("span",{class:"token punctuation"},")"),t("span",{class:"token punctuation"},";"),l(),t("span",{class:"token comment"},"// 使用 slice 创造数组副本，而不是引用"),l("\n      "),t("span",{class:"token keyword"},"return"),l("\n    "),t("span",{class:"token punctuation"},"}"),l("\n\n    "),t("span",{class:"token comment"},"// 从当前数字的索引开始，遍历 index-n 之间的所有数字"),l("\n    "),t("span",{class:"token keyword"},"for"),l(),t("span",{class:"token punctuation"},"("),t("span",{class:"token keyword"},"let"),l(" i "),t("span",{class:"token operator"},"="),l(" index"),t("span",{class:"token punctuation"},";"),l(" i "),t("span",{class:"token operator"},"<="),l(" n"),t("span",{class:"token punctuation"},";"),l(" i"),t("span",{class:"token operator"},"++"),t("span",{class:"token punctuation"},")"),l(),t("span",{class:"token punctuation"},"{"),l("\n      "),t("span",{class:"token comment"},"// 这是当前数字存在于组合中的情况"),l("\n      curr"),t("span",{class:"token punctuation"},"."),t("span",{class:"token function"},"push"),t("span",{class:"token punctuation"},"("),l("i"),t("span",{class:"token punctuation"},")"),t("span",{class:"token punctuation"},";"),l("\n      "),t("span",{class:"token comment"},"// 基于当前数字存在于组合中的情况，进一步 dfs（递归），遍历判断数组下一个元素的存在情况"),l("\n      "),t("span",{class:"token function"},"dfs"),t("span",{class:"token punctuation"},"("),l("i "),t("span",{class:"token operator"},"+"),l(),t("span",{class:"token number"},"1"),t("span",{class:"token punctuation"},")"),t("span",{class:"token punctuation"},";"),l("\n      "),t("span",{class:"token comment"},"// 底层递归结束后依次返回，pop 出当前递归层中添加的元素，并作为这是当前数字不存在与组合中的情况，再返回上一层时就可以添加到 res 中"),l("\n      curr"),t("span",{class:"token punctuation"},"."),t("span",{class:"token function"},"pop"),t("span",{class:"token punctuation"},"("),t("span",{class:"token punctuation"},")"),t("span",{class:"token punctuation"},";"),l("\n    "),t("span",{class:"token punctuation"},"}"),l("\n  "),t("span",{class:"token punctuation"},"}"),l("\n\n  "),t("span",{class:"token comment"},"// 从数组第一个元素进入 dfs"),l("\n  "),t("span",{class:"token function"},"dfs"),t("span",{class:"token punctuation"},"("),t("span",{class:"token number"},"1"),t("span",{class:"token punctuation"},")"),t("span",{class:"token punctuation"},";"),l("\n  "),t("span",{class:"token keyword"},"return"),l(" res"),t("span",{class:"token punctuation"},";"),l("\n"),t("span",{class:"token punctuation"},"}"),l("\n")])]),t("div",{class:"line-numbers"},[t("span",{class:"line-number"},"1"),t("br"),t("span",{class:"line-number"},"2"),t("br"),t("span",{class:"line-number"},"3"),t("br"),t("span",{class:"line-number"},"4"),t("br"),t("span",{class:"line-number"},"5"),t("br"),t("span",{class:"line-number"},"6"),t("br"),t("span",{class:"line-number"},"7"),t("br"),t("span",{class:"line-number"},"8"),t("br"),t("span",{class:"line-number"},"9"),t("br"),t("span",{class:"line-number"},"10"),t("br"),t("span",{class:"line-number"},"11"),t("br"),t("span",{class:"line-number"},"12"),t("br"),t("span",{class:"line-number"},"13"),t("br"),t("span",{class:"line-number"},"14"),t("br"),t("span",{class:"line-number"},"15"),t("br"),t("span",{class:"line-number"},"16"),t("br"),t("span",{class:"line-number"},"17"),t("br"),t("span",{class:"line-number"},"18"),t("br"),t("span",{class:"line-number"},"19"),t("br"),t("span",{class:"line-number"},"20"),t("br"),t("span",{class:"line-number"},"21"),t("br"),t("span",{class:"line-number"},"22"),t("br"),t("span",{class:"line-number"},"23"),t("br"),t("span",{class:"line-number"},"24"),t("br"),t("span",{class:"line-number"},"25"),t("br"),t("span",{class:"line-number"},"26"),t("br"),t("span",{class:"line-number"},"27"),t("br"),t("span",{class:"line-number"},"28"),t("br"),t("span",{class:"line-number"},"29"),t("br"),t("span",{class:"line-number"},"30"),t("br"),t("span",{class:"line-number"},"31"),t("br"),t("span",{class:"line-number"},"32"),t("br"),t("span",{class:"line-number"},"33"),t("br"),t("span",{class:"line-number"},"34"),t("br"),t("span",{class:"line-number"},"35"),t("br"),t("span",{class:"line-number"},"36"),t("br"),t("span",{class:"line-number"},"37"),t("br")])],-1),P=t("h2",{id:"解题模板",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#解题模板","aria-hidden":"true"},"#"),l(" 解题模板")],-1),Q=t("p",null,"解题模板解决三个核心问题：",-1),T=t("ul",null,[t("li",null,"什么时候用？（明确场景）"),t("li",null,"为什么这样用？（提供依据）"),t("li",null,"怎么用？（细化步骤）")],-1),U=t("p",null,"以下是涉及递归与回溯，或者说涉及 DFS 应用题目的解题模板：",-1),V=t("p",null,[t("strong",null,"什么时候用")],-1),W=t("p",null,"看两个特征：",-1),X=t("ol",null,[t("li",null,[l("题目中暗示了一个或多个解，并且要求我们"),t("strong",null,"详尽地列举出每一个解"),l("的内容时，一定要想到 DFS、想到递归回溯。")]),t("li",null,[l("题目经分析后，可以转化为"),t("strong",null,"树形逻辑模型"),l("求解。")])],-1),Y=t("p",null,[t("strong",null,"为什么这样用")],-1),Z=t("p",null,[l("递归与回溯的过程本身就是"),t("strong",null,"穷举"),l("的过程。题目中要求我们列举每一个解的内容，解是基于穷举思想、对搜索树进行恰当地剪枝后得来的。")],-1),$=t("p",null,[l("💡 如果题目只问解的个数（不问解的内容），这类问题往往不用 DFS 来解，而是用"),t("strong",null,"动态规划"),l("。")],-1),nn=t("p",null,[t("strong",null,"怎么用")],-1),sn=t("ul",null,[t("li",null,"一个模型——树形逻辑模型。树形逻辑模型的构建关键在于找「坑位」，一个坑位就对应树中的一层，每一层的处理逻辑往往是一样的，这个逻辑就是递归式的内容。"),t("li",null,"两个要点——递归式和递归边界。基于在题目中约束得出递归边界，如默认为「坑位」数量的边界。")],-1),an=t("p",null,"用伪代码总结一下编码形式：",-1),tn=t("div",{class:"language-javascript ext-js line-numbers-mode"},[t("pre",{class:"language-javascript"},[t("code",null,[t("span",{class:"token keyword"},"function"),l(),t("span",{class:"token function"},"xxx"),t("span",{class:"token punctuation"},"("),t("span",{class:"token parameter"},"入参"),t("span",{class:"token punctuation"},")"),l(),t("span",{class:"token punctuation"},"{"),l("\n  "),t("span",{class:"token comment"},"// 前期的变量定义、缓存等准备工作"),l("\n\n  "),t("span",{class:"token comment"},"// 定义路径栈"),l("\n  "),t("span",{class:"token keyword"},"const"),l(" path "),t("span",{class:"token operator"},"="),l(),t("span",{class:"token punctuation"},"["),t("span",{class:"token punctuation"},"]"),l("\n\n  "),t("span",{class:"token comment"},"// 定义核心（递归）函数 dfs"),l("\n  "),t("span",{class:"token function"},"dfs"),t("span",{class:"token punctuation"},"("),t("span",{class:"token parameter"},"递归参数"),t("span",{class:"token punctuation"},")"),l(),t("span",{class:"token punctuation"},"{"),l("\n    "),t("span",{class:"token keyword"},"if"),t("span",{class:"token punctuation"},"("),l("到达了递归边界"),t("span",{class:"token punctuation"},")"),l(),t("span",{class:"token punctuation"},"{"),l("\n      "),t("span",{class:"token comment"},"// 结合题意处理边界逻辑，往往和 path 内容有关"),l("\n      "),t("span",{class:"token comment"},"// 到达递归边界返回（回溯）"),l("\n      "),t("span",{class:"token keyword"},"return"),l("\n    "),t("span",{class:"token punctuation"},"}"),l("\n\n    "),t("span",{class:"token comment"},"// 注意这里也可能不是 for，视题意决定"),l("\n    "),t("span",{class:"token keyword"},"for"),t("span",{class:"token punctuation"},"("),l("遍历坑位的可选值"),t("span",{class:"token punctuation"},")"),l(),t("span",{class:"token punctuation"},"{"),l("\n      path"),t("span",{class:"token punctuation"},"."),t("span",{class:"token function"},"push"),t("span",{class:"token punctuation"},"("),l("当前选中值"),t("span",{class:"token punctuation"},")"),l("\n      "),t("span",{class:"token comment"},"// 处理坑位本身的相关逻辑"),l("\n      path"),t("span",{class:"token punctuation"},"."),t("span",{class:"token function"},"pop"),t("span",{class:"token punctuation"},"("),t("span",{class:"token punctuation"},")"),l("\n    "),t("span",{class:"token punctuation"},"}"),l("\n  "),t("span",{class:"token punctuation"},"}"),l("\n\n  "),t("span",{class:"token comment"},"// 进入 dfs"),l("\n  "),t("span",{class:"token function"},"dfs"),t("span",{class:"token punctuation"},"("),l("起点"),t("span",{class:"token punctuation"},")"),l("\n\n  "),t("span",{class:"token comment"},"// 返回结果"),l("\n  "),t("span",{class:"token keyword"},"return"),l(" res"),t("span",{class:"token punctuation"},";"),l("\n"),t("span",{class:"token punctuation"},"}"),l("\n")])]),t("div",{class:"line-numbers"},[t("span",{class:"line-number"},"1"),t("br"),t("span",{class:"line-number"},"2"),t("br"),t("span",{class:"line-number"},"3"),t("br"),t("span",{class:"line-number"},"4"),t("br"),t("span",{class:"line-number"},"5"),t("br"),t("span",{class:"line-number"},"6"),t("br"),t("span",{class:"line-number"},"7"),t("br"),t("span",{class:"line-number"},"8"),t("br"),t("span",{class:"line-number"},"9"),t("br"),t("span",{class:"line-number"},"10"),t("br"),t("span",{class:"line-number"},"11"),t("br"),t("span",{class:"line-number"},"12"),t("br"),t("span",{class:"line-number"},"13"),t("br"),t("span",{class:"line-number"},"14"),t("br"),t("span",{class:"line-number"},"15"),t("br"),t("span",{class:"line-number"},"16"),t("br"),t("span",{class:"line-number"},"17"),t("br"),t("span",{class:"line-number"},"18"),t("br"),t("span",{class:"line-number"},"19"),t("br"),t("span",{class:"line-number"},"20"),t("br"),t("span",{class:"line-number"},"21"),t("br"),t("span",{class:"line-number"},"22"),t("br"),t("span",{class:"line-number"},"23"),t("br"),t("span",{class:"line-number"},"24"),t("br"),t("span",{class:"line-number"},"25"),t("br"),t("span",{class:"line-number"},"26"),t("br"),t("span",{class:"line-number"},"27"),t("br"),t("span",{class:"line-number"},"28"),t("br")])],-1);p.render=function(l,p){const en=n("RouterLink");return s(),a(c,null,[o,u,r,i,k,b,m,d,f,g,t("p",null,[h,w,y,t(en,{to:"/algorithm/Frontend/DFS%E5%92%8CBFS.html#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"},{default:e((()=>[v])),_:1}),x]),j,F,S,D,E,B,_,q,A,C,M,L,R,z,G,H,I,J,K,N,O,P,Q,T,U,V,W,X,Y,Z,$,nn,sn,an,tn],64)};export default p;
